---
marp: true
title: Marp
paginate: true
style: |
  .red {
    color: red;
  }
  .green {
    color : green;
  }
  .blue {
    color : blue;
  }
---

# 성능

웹 성능은 웹페이지가 로딩되고 작동하는 속도와 효율성을 측정한 것이다.
대규모 웹 애플리케이션에서 최적의 성능을 유지하는 것은 긍정적인 사용자 경험을 보장하는데 매우 중요하다.
애플리케이션의 규모가 커지면 트래픽 증가, 무거운 리소스 사용, 광범위한 기능으로 인해 점점 성능 유지가 어려워지기 때문이다.
<br>
이번 장에서는 성능 최적화에 관한 몇 가지 핵심 개념을 살펴본다.

---

## 🖥️ 브라우저는 어떻게 작동하는가?

### 렌더링

서버 -> 브라우저 ( HTML, CSS -> DOM,CSSOM 생성) -> 렌더링

- 렌더링의 2단계

1. 레이아웃
   - 크기 & 위치
2. 페인트
   - 그리기

---

### 로딩

브라우저는 HTML문서를 받으면 이에 참조된 리소스(ex:이미지,스크립트 등...)을 로딩하기 시작한다.
로딩 프로세스는 특히 리소스가 많을 경우 병목이 될 수 있다.
<br>

- prefetching (미리 가져오기)
- preloading (미리 로딩하기)
- resource hint (리소스 힌트)
  <br>
  이 3가지를 이용해서 브라우저에게 미래에 사용할 리소스에 관한 정보를 제공할 수 있다.

---

## 💴 자바스크립트에서의 비용 이해하기와 줄이기

JS는 모던 웹 개발의 핵심 요소가 되었다.
하지만,
❗️JS를 사용하는 비용은 성능,다운로드 시간,CPU 실행시간 과 관련해 부정적인 영향을 미칠 수 있다.
<br>

### 1. 다운로드 시간(네트워크 전송) 줄이기

    JS 번들 크기 작게 (📱을 위해) 유지 👉 다운로드 속도 개선, 메모리 적게 사용, CPU 비용 ⬇️

---

### 2. 실행 시간 줄이기

메인 스레드가 긴 테스크를 실행하느라 바쁘면 사용자 상호작용은 지연 될 수 있다.

    - 긴 테스크들은 메인 스레드를 점유하므로 작은 테스크로 분할
    - 코드를 분할하고 로드되는 순서의 우선순위를 지정

<br>

### 3. 파싱과 컴파일

지난 몇 년간 JS관련 비용의 가장 주목할 만한 변화는 브라우저의 스크립트 파싱 및 컴파일 속도가 크게 향상 되었다는 점이다.
모던 JS엔진인 V8은 메인 스레드를 중지시키지 않고 JS를 파싱 및 컴파일할 수 있다.
(이전 버전의 크롬은 스크립트 전체를 다운로드한 뒤 파싱을 시작)

---

V8엔진의 [코드 캐싱](https://v8.dev/blog/code-caching-for-devs#code-caching-recap) 최적화도 도움이 된다.

1. 스크립트 처음 요청 (콜드 런)
2. 크롬은 스크립트를 다운로드하고 V8에게 컴파일을 지시 + 스크립트를 브라우저의 디스크 캐시에 저장
3. 스크립트 두번째 요청 (웜 런)
4. 크롬은 요청 받은 파일을 브라우저 캐시에서 꺼내고 V8에게 재컴파일 지시
5. 컴파일된 코드는 직렬화되어 캐싱된 스크립트 파일에 메타데이터로 추가
6. 스크립트 세번째 요청 (핫 런)
7. 크롬은 두 파일을 모두 꺼내고 캐시에서 해당 파일의 메타 데이터를 꺼내 V8에게 전달
8. V8은 메타데이터를 역직렬화하고 컴파일을 건너뛴다.
9. 첫 두 번의 방문이 72시간 안에 발생하면 코드 캐싱을 실행

---

### 4. 모바일 기기

JS는 모바일 기기의 배터리 수명에도 영향을 미칠 수 있다.

- 많은 CPU 리소스 필요
- 배터리가 빨리 소진되게 할 수 있음

<br>

JS 실행은 CPU와 연관 되므로 JS성능에 매우 중요하다.

- JS 번들의 크기를 줄인다.
- 큰 번들을 작은 번들로 나눈다.
- 메인 스레드를 블로킹 할 수 있는 긴 태스크를 피한다.

---

## 🔧 상호작용 최적화

상호작용 대비

> 사용자의 상호작용에 대해 웹페이지가 얼마나 빠르게 반응할 수 있는지를 평가하는 웹 성능 지표이다.

사용자는 웹페이지가 자신의 입력 (클릭, 스크롤, 타이핑 등...) 에 즉각 반응하기를 원한다.
startTransition 과 Suspense를 통해 구현되는 React.js <span class="red" >타임 슬라이싱</span>을 사용하면 선택적이고 점진적인 흡수(hydration)를 활성화 할 수 있으며 언제든 방해를 받을 수 있는 작은 슬라이스 안에서 흡수할 수 있다.
<br>
🧠 타임 슬라이싱

> 큰 작업을 한 번에 다 하지 않고, 잘게 쪼개서 조금씩 처리하며 사용자 인터랙션을 우선시하는 방식

---

## 🔗 네트워킹

🛜 HTTP/3

> HTTP/3 HTTP의 새로운 버전, 인터넷에 관한 성능과 보안을 개선하기 위해 설계
> QUIC 전송 프로토콜을 사용
> 이 프로토콜을 지연과 혼잡을 줄이고, 멀티플렉스 스트림과 커넥션 마이그레이션을 지원하기 위해 설계

🛤️ 스트리밍 (streaming)

> 전체 파일 혹은 리소스가 로딩될 때까지 기다리지 않고 데이터를 덩어리 혹은 조각으로 보내고 받을 수 있는 능력

🤏 플러싱 (flushing)

> 전체 응답이 생성되기 전에 데이터를 브라우저에게 보낼 수 있는 능력

---

## ⛓️‍💥 서드파티 의존성의 영향 줄이기

대규모 JS와 React 애플리케이션에서 작업할 때 서드파티 의존성은 때때로 성능 병목에 가장 큰 영향을 주는 요소가 될 수 있다.

<br>

### 1. 가장 느린 의존성을 식별하라

Chrome DevTools, Lighthouse, WebPageTest 같은 도구를 활용해서 가장 느리게 로딩되는 서드파티 의존성을 식별

### 2. 각 의존성의 필요성을 평가하라

애플리케이션의 핵심 기능에 필수적인가?
이들을 더 작거나 빠른 대안으로 대체할 수 있는가?

---

### 3. 대체 라이브러리를 고려하라

핵심 기능에 필수적이지 않다면 해당 의존성을 더 작고 빠른 대안 라이브러리로 대체할 것을 고려

### 4. 의존성 로딩을 최적화하라

지연 로딩, 코드 분할, 트리 셰이킹 같은 기법을 사용해서 서드파티의 의존성의 로딩을 최적화 할 수 있다.

### 5. CDN 호스팅을 사용하라

CDN 호스팅을 사용하면 로딩 시간을 줄이고 애플리케이션 성능을 개선하는데 도움이 될 수 있다.
❗️ <span class="red">더블 키 캐싱</span>을 사용하면 CDN 캐싱의 이익을 크게 줄일 수 있다는 점에 유의하라.

✅ Double Key Caching이란?

> 캐싱 전략중 하나로, 캐시 키를 단일 키(URL)만이 아니라, 추가 정보(예: 쿠키, 헤더 등)를 포함해서 "2개 이상의 키"로 구성하는 전략

---

### 6. 번들을 분석하라

Webpack Bundle Analyzer, Lighthouse Treemap 같은 도구를 사용하면 번들을 분석하고 가장 많은 공간을 차지하는 의존성을 식별하는 데 도움을 얻을 수 있다.

### 7. 서드파티 의존성 구성을 최적화 하라

몇몇 서드 파티 의존성은 그 성능을 개선하기 위해 최적화될 수 있는 구성을 갖는다.
예를 들면 데이터 시각화 라이브러리를 사용한다면 표시되는 항목의 수를 제한함으로써 렌더링하는 데이터양을 줄일 수 있다.

---

## 💻 렌더링 패턴

렌더링 패턴은 시간이 지남에 따라 지속적으로 진화해왔다.

- SPA : 브라우저에서 완전하게 실행되는 애플리케이션
- MPA : 최소한의 SPA의 동적 동작과 함께 서버에서 완전하게 실행되는 애플리케이션
- SSG : 사전 렌더링된 정적 콘텐츠, SPA의 동적요소 포함할 수 있음
- SSR : HTML 콘텐츠를 클라이언트에서 흡수하기전에 서버에서 동적으로 렌더링
- 부분적 흡수 : 클라이언트에서 컴포넌트의 일부만 흡수함 (RSC)
- 점진적 흡수 : 클라이언트에서 컴포넌트 흡수 순서 통제하기
- 아일랜드 아키텍처 : 정적 사이트에 여러 엔드리 포인트가 있는 동적 행동의 고립된 섬
- 점진적인 정적 생성 : 초기 구축 이후에도 정적 사이트를 동적으로 증강하거나 수정할 수 있는 능력 (Next.js ISR)
- 스트리밍 SSR : 서버 측에서 렌더링된 콘텐츠를 작은 스트림 덩어리로 나누는 것

---

- 재개 가능성 : 서버에서 프레임워크 상태를 직렬화해 클라이언트가 중복된 코드 없이 실행을 재개할 수 있음
- 에지 렌더링 : 렌더링된 HTML을 에지에서 대체한 뒤 이를 클아이언트로 보냄

<br>

## 🔩 인지된 성능 최적화하기

인지된 성능

> 웹사이트 혹은 애플리케이션의 로딩 및 응답 속도와 관련된 주관적인 경험이며, 실제 로딩되는 정확한 시간되는 대비된다.

---

점진적 로딩 ( 예 : 스켈레톤 스크린 )은 인지된 성능을 개선하는 기법의 하나이다.

- 장점
  - 웹 사이트의 인지된 성능을 전반적 개선
  - 빠르게 콘텐츠를 표시함으로써 사용자가 흥미를 가질 수 있도록 유지하는데 도움
  - 중요한 콘텐츠의 우선순위를 높임으로써 서버 네트워크의 부하 줄이는데 도움
- 단점
  - 보다 복잡한 코딩과 설계 필요 -> 구현과 유지보수 부담
  - 올바르게 구현하지 않으면 사용자의 주의를 산만하게함
  - 모든 콘텐츠에 적합하지 않을 수 있다.
  - 다양한 기기 , 플랫폼에서 접근할 수 있고 잘 호환되는 방식으로 구현 되어야 한다.
