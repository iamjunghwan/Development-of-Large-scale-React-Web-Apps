---
marp: true
title: Marp
paginate: true
style: |
  .red {
    color: red;
  }
  .green {
    color : green;
  }
  .blue {
    color : blue;
  }
---

# 자바스크립트에서의 모듈

자바스크립트 모듈을 사용하면 코드를 작은 파일로 나누어서 기능을 export/import할 수 있다.

<br>

- export 선언 : 함수, 객체, 프리미티브 등 모든 것
- import 선언 : 다른 모듈

<br>

> 모듈을 사용하면 <span class="red">재사용성</span>과 <span class="red">유지보수성</span>이 높아진다.

<br>

---

## 1. 리액트의 컴포넌트화

### &emsp; 1-1. 재사용 가능한 컴포넌트를 식별하라

- 버튼, 메뉴, 카드 같이 반복되는 요소들
- 헤더, 콘텐츠 영역, 푸터 같은 페이지의 구역들
- 기능의 논리적 덩어리

<br>

### &emsp; 1-2. 애플리케이션을 작은 컴포넌트로 나눠라

<br>

### &emsp; 1-3. 디자인 시스템을 구현하라

---

## 지연로딩

지연 로딩은 리소스가 <span class="red">필요할 때</span>만 로딩하는 기법

- lazy : 요청이 있을 때 컴포넌트를 로딩할 수 있게 하는 함수
- Suspense : 지연 컴포넌트가 로딩되는 동안 대체 fallback컴포넌트를 표시하기 위해 사용하는 컴포넌트

<br>

---

### 1. <span class="red">정적</span> 임포트

```
import Post from './components/Post'
```

<br>

### 2. <span class="red">동적</span> 임포트

```
const Post = lazy(()=>import("./component/Post"))

return (
  <Suspense fallback={<div>Loading...</div>}>
    <Post/>
  </Suspense>
)
```

<br>

---

### 3. <span class="red">상호작용</span>에 대한 지연로딩

```
const handleClick = () =>{
  import("./compoenets/Post").then((module) =>{
    setPost(()=>module.default);
  })
}
```

<br>

### 4. <span class="red">Intersection Observer API</span>를 사용한 지연로딩

Intersection Observer는 JS API이며, 이를 사용하면 뷰포트에 어떤 요소가 표시되는 시점을 식별 가능하다.

<br>

---

# 코드분할

애플리케이션 코드 전체를 보다 작은, 관리 가능한 덩어리로 나눔으로써 대규모 어플리케이션의 성능을 최적화하는 기법

<br>

### 리액트에서 공통적 코드 분할 패턴

- 라우트에 따라 분할 : 페이지 모듈을 로딩
- 컴포넌트에 따라 분할 : 큰 컴포넌트 지연로딩
- 온디맨드 로딩 : 사용자가 버튼, 드롭다운 등을 클릭할 때 코드를 로딩

---

# 코드 분할 기법에 접근하는 전략

### 엔드리 포인트 분할

웹 사이트를 방문했을 때 로딩되는 첫 번째 JS 파일

<br>

### 벤더 분할

서드파티 의존성을 분리할 때 사용하는 기법
서드파티 의존성과 관련된 코드를 별도의 덩어리로 잘라내 독립적으로 <span class="red">캐싱</span>

<br>

---

### 동적 분할

JS 코드를 필요할 때 필요한 만큼 로딩할 때 사용하는 기법
사용자 상호작용, 다른 런타임 조건에 따라 코드베이스의 다른 부분들이 로딩될 때 점진적 통제 가능

<br>

### 컴포넌트 수준 분할

각 컴포넌트를 필요할 때만 지연 로딩

<br>

### 라우트 기반 분할

사용자가 다른 라우트를 방문하면 적절한 번들을 필요에 따라 로딩하며,
👍 초기에 다운로드해야 할 코드의 양을 줄인다.
☠️ 네트워크 대역폭 사용 관점에서는 컴포넌트 수준 코드 분할보다 효율적이지 않을 수 있다.

---

### 공격적인 코드 분할의 트레이드 오프 (지나친 코드 분할의 단점)

JS를 수많은 작은 덩어리로 과도하게 자르는 프랙티스를 가리킨다.

- 입도 트레이드 오프
  👍 : 캐싱, 중복 제거 관점
  ☠️ : 브라우저 성능 관점

- 상호 운용성
  ☠️ : 브라우저, 서버, CDN마다 코드 분할을 다르게 구현할 수 있으며, 이는 호환성 이슈로 이어질 수 있다.

- 오버헤드
  ☠️ : 여러 파일의 처리, 가져오기, 파싱을 위해 필요한 추가적인 오버헤드를 발생시킬 수 있다.

---

- 디버깅
  ☠️ : 수많은 작은 덩어리들로 구성된 코드가 여러 파일에 분산되어 있기 때문에 코드를 디버그하고 이슈를 식별하기 어려울 수 있다.

- 빌드 복잡성
  ☠️ : 빌드 프로세스를 한층 복잡하며 오랜 시간을 소요하게 만든다.

---

# 정리

컴포넌트를 모듈화 하게 되면 애플리케이션을 유지보수 가능하고 확장 가능하게 만드는 동시에 개발자 경험을 향상할 수 있다.

코드 분할을 사용하면 애플리케이션을 관리 가능한 덩어리로 나눌 수 있고,
이를 통해 사용자가 필요한 코드를 적절한 시점에 로딩하도록 보장할 수 있다.
